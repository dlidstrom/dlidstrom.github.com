#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"fsharp"},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!fsharp

#r "nuget: Plotly.NET.Interactive"
#r "nuget: Plotly.NET.ImageExport"

(*
Till n칛sta m칛sterskap: p친 slutet n칬r det
칛r dags f칬r slutspel, d친 vill man veta
sina vinstchanser. Man vill veta chans p친
1:a, 2:a och 3:e plats. En komplicerad
utr칛kning minst sagt. Kolla p친b칬rjad
funktion l칛ngst ner.

Det 칛r ocks친 roligare om allas namn har
landet dom tippat p친 som flagga i alla
diagram.

Det 칛r ocks친 kul om det g친r att anv칛nda
api football. Oklart hur men kanske g친r
att hitta p친 n친t skoj?

Sist s친 칛r det m친nga m칛sterskap. K칬r ocks친
dam-m칛sterskapen. Finns det andra? Mellan
sl칛kten 칛r det b칛st om Sverige 칛r med eller
om det 칛r "k칛nda" l칛nder. D친 k칬r vi inte
asiatiska m칛sterskapen antar jag...
*)

#!fsharp

open System.IO
open System.Text.RegularExpressions
open Giraffe.ViewEngine
open Plotly.NET
open Plotly.NET.ImageExport
open Plotly.NET.Interactive

type BetRow = {
    Name : string
    Guesses : string list
    Winner : string
}

type ScoredRow = {
    Name : string
    Scores : float list
    Guesses : string list
}

type ScoredChart = {
    Sum: float
    Name: string
}

let results =
    "resultat.txt"
    |> File.ReadAllLines
    |> Array.map (fun s -> string s[0])
    |> Array.where (fun s -> s.Length > 0)
    |> List.ofArray
let matches =
    "matcher.txt"
    |> File.ReadAllLines
    |> List.ofArray
let betRows =
    let createBetRow (a: string array) = {
        Name = a[2]
        Winner = a[24 + 3] // 24 matches
        Guesses = a[3..26] |> List.ofArray  // 24 + 3 (timestamp parts) - 1 (0-based indexing)
    }
    "tipset.2025.txt"
    |> File.ReadAllLines
    |> Seq.where (fun l -> l.StartsWith('#') = false)
    |> Seq.map (fun l -> Regex.Split(l, @"\s+"))
    |> Seq.map createBetRow
    |> Seq.toList
let countryToFlag =
    Map [
        "Sverige", "游젏릖"
        "England", "游섫릖"
        "Frankrike", "游游"
        "Tyskland", "游뾇릖"
        "Spanien", "游쀯릖"
        "Italien", "游쉻릖"
        "Nederl칛nderna", "游游"
        "Portugal", "游왫릖"
        "Schweiz", "游뻟릖"
        "Turkiet", "游좷릖"
        "Kroatien", "游쇓릖"
        "Belgien", "游游"
        "Danmark", "游뾇릖"
        "Polen", "游왫릖"
        "Tjeckien", "游뻟릖"
        "Serbien", "游游"
        "Skottland", "游낎"
        "Norge", "游游"
        "Finland", "游游"
        "Island", "游쉻릖"
        "Ukraina", "游쥟릖"
        "Ryssland", "游游"
        "칐sterrike", "游뷣릖"
        "Ungern", "游쇓릖"
        "Rum칛nien", "游游"
        "Slovakien", "游젏릖"
        "Slovenien", "游젏릖"
        "Grekland", "游섫릖"
        "Irland", "游쉻릖"
        "Wales", "游낎"
        "Albanien", "游뷣릖"
        "Bulgarien", "游游"
        "Bosnien", "游游"
        "Nordmakedonien", "游쓇릖"
        "Luxemburg", "游쐟릖"
        "Georgien", "游섫릖"
        "Kosovo", "游쬃릖"
        "Estland", "游쀯릖"
        "Lettland", "游쐟릖"
        "Litauen", "游쐟릖"
        "Montenegro", "游쓇릖"
        "Armenien", "游뷣릖"
        "Azerbajdzjan", "游뷣릖"
        "Israel", "游쉻릖"
        "Malta", "游쓇릖"
        "Cypern", "游뻟릖"
        "Kazakstan", "游썷릖"
        "Liechtenstein", "游쐟릖"
        "Andorra", "游뷣릖"
        "San Marino", "游젏릖"
        "F칛r칬arna", "游游"
        "Gibraltar", "游섫릖"
        "Moldavien", "游쓇릖"
        "Vitryssland", "游游"
        "USA", "游쥟릖"
        "Brasilien", "游游"
        "Argentina", "游뷣릖"
        "Mexiko", "游쓇릖"
        "Japan", "游游"
        "Sydkorea", "游썷릖"
        "Australien", "游뷣릖"
        "Kanada", "游뻟릖"
        "Kina", "游뻟릖"
        // L칛gg till fler vid
    ]

let nameWithFlag (name: string) =
    // Handles names like "Sverige - Finland"
    let parts = name.Split([| " - " |], System.StringSplitOptions.None)
    parts
    |> Array.map (fun n ->
        match countryToFlag.TryFind n with
        | Some flag -> $"{flag} {n}"
        | None -> n)
    |> String.concat " - "

let colorPalette =
  [ "#1f77b4"; // blue
    "#ff7f0e"; // orange
    "#2ca02c"; // green
    "#d62728"; // red
    "#9467bd"; // purple
    "#8c564b"; // brown
    "#e377c2"; // pink
    "#7f7f7f"; // gray
    "#bcbd22"; // olive
    "#17becf"; // cyan
    "#aec7e8"; // light blue
    "#ffbb78"; // light orange
    "#98df8a"; // light green
    "#ff9896"; // light red
    "#c5b0d5"; // light purple
    "#c49c94"; // light brown
    "#f7b6d2"; // light pink
    "#c7c7c7"; // light gray
    "#dbdb8d"; // light olive
    "#9edae5"  // light cyan
  ]
  |> List.map Plotly.NET.Color.fromHex
let getColorForName (name: string) =
    let hash = abs (name.GetHashCode())
    colorPalette[hash % colorPalette.Length]

let nameToColor =
    betRows
    |> List.map (fun br -> br.Name, getColorForName br.Name)
    |> Map.ofList

let countCorrect i r =
    let count =
        betRows
        |> Seq.where (fun br -> br.Guesses[i] = r)
        |> Seq.length
        |> double
    let score =
        if count > 0 then (float betRows.Length) / count
        else 0
    score, r
let correctPerGame =
    results |> List.mapi countCorrect
let scoreGuesses (guesses: string list) =
    let scoreGame i (fs: float * string) =
        let f, s = fs
        if s = guesses[i] then f
        else 0
    correctPerGame
    |> List.mapi scoreGame
let scoredRowsFirst =
    let convertGuesses guesses =
        let scores = scoreGuesses guesses
        scores |> List.scan (+) 0.
    let createScoredRow (br: BetRow) =
        { Name = br.Name
          Scores = convertGuesses br.Guesses
          Guesses = br.Guesses }
    betRows
    |> List.map createScoredRow

let scoredRows =
    let addWinnerPoints (sc: ScoredRow) =
        { Name = sc.Name
          Scores = sc.Scores @ [100.]
          Guesses = sc.Guesses @ [ "F" ] }
    scoredRowsFirst
    //|> List.map addWinnerPoints

let createChart (sr: ScoredRow) =
    let xData = [0..results.Length]
    let sum = sr.Scores[results.Length]
    let chart = Chart.Spline(
        xData,
        sr.Scores,
        Name = $"%s{sr.Name} %.1f{sum}",
        Smoothing = 0.3,
        LineColor = nameToColor[sr.Name],
        MarkerColor = nameToColor[sr.Name],
        ShowMarkers = true,
        MultiText = [""] @ (sr.Guesses[0..results.Length - 1]),
        TextPosition = StyleParam.TextPosition.BottomCenter,
        ShowLegend = true)
    sum, chart
let description =
  if matches.Length > results.Length then
    [
      h3 [] [str "Kommande matcher och v친ra tips"]
      table [] [
        tr [] [
          th [] []
          for sr in scoredRows do
            th [] [str sr.Name]
        ]
        for m = 0 to 3 do
          let mtch = matches[results.Length + m]
          tr [] [
            td [] [str (nameWithFlag mtch)]
            for sr in scoredRows do
              td [] [str sr.Guesses[results.Length + m]]
          ]
      ]
    ]
  else
    [
      h3 [] [str "V친ra slutvinnare"]
      table [] [
        tr [] [
          th [] [str "Namn"]
          th [] [str "Slutvinnare"]
        ]
        for br in betRows do
          tr [] [
            td [] [str br.Name]
            td [] [str br.Winner]
          ]
      ]
    ]

let myFirstChart =
    Chart.combine(
        scoredRows
        |> List.map createChart
        |> List.sortByDescending fst
        |> List.map snd
    )
    |> Chart.withTitle "EURO 2025 丘쬂잺"
    |> Chart.withAdditionalHeadTags
        [ link
              [ _rel "stylesheet"
                _href "https://cdn.jsdelivr.net/npm/bulma@0.9.2/css/bulma.min.css" ] ]
    |> Chart.withDescription(description)
myFirstChart |> Chart.savePNG("chart", Width = 1400, Height = 1000)
myFirstChart

#!fsharp

let matchup teams =
  let iseve x = x % 2 = 0
  let isodd = not << iseve
  let eve, odd =
    teams
    |> List.mapi (fun i x -> (i, x))
    |> List.partition (fst >> iseve)
  List.zip (eve |> List.map snd) (odd |> List.map snd)
//let teams = ["ESP"; "GER"; "POR"; "FRA"; "NED"; "TUR"; "ENG"; "SUI"]
let teams = ["ESP"; "GER"; "POR"; "FRA"]
let matchups = matchup teams

// from each match, select winner by choosing fst or snd
matchups

#!fsharp

printfn "matchups: %A" matchups
let pad n = new string(' ', n)
let outcomes matchups debug = seq {
  let rec pairItems = function
  | [] -> []
  | [x] -> failwith "unexpected 1 element"
  | x :: y :: rest -> (x, y) :: pairItems rest
  let rec outcomes' matchups acc indent = seq {
    if debug then printfn "%smatchups: %A acc: %A" (pad indent) matchups acc
    match matchups with
    | (home, away) :: rest ->
      if debug then printfn "%shome: %A away: %A rest: %A" (pad indent) home away rest
      let homeWins = outcomes' rest ([home] @ acc) (indent + 1) |> List.ofSeq
      let awayWins = outcomes' rest ([away] @ acc) (indent + 1) |> List.ofSeq
      if debug then printfn "%shomeWins: %A awayWins: %A" (pad indent) homeWins awayWins
      yield! homeWins
      yield! awayWins
    | [] ->
      if debug then printfn "%s final acc: %A" (pad indent) acc
      yield List.rev acc
  }
  let result =
    outcomes' matchups [] 0
    |> Seq.collect id
    |> Seq.toList
    |> pairItems
  yield! result
}

let advances = outcomes matchups false |> Seq.toList
printfn "advances: %A" advances
