#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"fsharp"},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!fsharp

#r "nuget: Plotly.NET.Interactive"
#r "nuget: Plotly.NET.ImageExport"

(*
Till nÃ¤sta mÃ¤sterskap: pÃ¥ slutet nÃ¶r det
Ã¤r dags fÃ¶r slutspel, dÃ¥ vill man veta
sina vinstchanser. Man vill veta chans pÃ¥
1:a, 2:a och 3:e plats. En komplicerad
utrÃ¤kning minst sagt. Kolla pÃ¥bÃ¶rjad
funktion lÃ¤ngst ner.

Det Ã¤r ocksÃ¥ roligare om allas namn har
landet dom tippat pÃ¥ som flagga i alla
diagram.

Det Ã¤r ocksÃ¥ kul om det gÃ¥r att anvÃ¤nda
api football. Oklart hur men kanske gÃ¥r
att hitta pÃ¥ nÃ¥t skoj?

Sist sÃ¥ Ã¤r det mÃ¥nga mÃ¤sterskap. KÃ¶r ocksÃ¥
dam-mÃ¤sterskapen. Finns det andra? Mellan
slÃ¤kten Ã¤r det bÃ¤st om Sverige Ã¤r med eller
om det Ã¤r "kÃ¤nda" lÃ¤nder. DÃ¥ kÃ¶r vi inte
asiatiska mÃ¤sterskapen antar jag...
*)

#!fsharp

open System.IO
open System.Text.RegularExpressions
open Giraffe.ViewEngine
open Plotly.NET
open Plotly.NET.ImageExport
open Plotly.NET.Interactive

type BetRow = {
    Name : string
    Guesses : string list
    Winner : string
}

type ScoredRow = {
    Name : string
    Scores : float list
    Guesses : string list
}

type ScoredChart = {
    Sum: float
    Name: string
}
let countryToFlag =
    Map [
        "Sverige", "ðŸ‡¸ðŸ‡ª"
        "England", "ðŸ‡¬ðŸ‡§"
        "Frankrike", "ðŸ‡«ðŸ‡·"
        "Tyskland", "ðŸ‡©ðŸ‡ª"
        "Spanien", "ðŸ‡ªðŸ‡¸"
        "Italien", "ðŸ‡®ðŸ‡¹"
        "NederlÃ¤nderna", "ðŸ‡³ðŸ‡±"
        "Portugal", "ðŸ‡µðŸ‡¹"
        "Schweiz", "ðŸ‡¨ðŸ‡­"
        "Turkiet", "ðŸ‡¹ðŸ‡·"
        "Kroatien", "ðŸ‡­ðŸ‡·"
        "Belgien", "ðŸ‡§ðŸ‡ª"
        "Danmark", "ðŸ‡©ðŸ‡°"
        "Polen", "ðŸ‡µðŸ‡±"
        "Tjeckien", "ðŸ‡¨ðŸ‡¿"
        "Serbien", "ðŸ‡·ðŸ‡¸"
        "Skottland", "ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿"
        "Norge", "ðŸ‡³ðŸ‡´"
        "Finland", "ðŸ‡«ðŸ‡®"
        "Island", "ðŸ‡®ðŸ‡¸"
        "Ukraina", "ðŸ‡ºðŸ‡¦"
        "Ryssland", "ðŸ‡·ðŸ‡º"
        "Ã–sterrike", "ðŸ‡¦ðŸ‡¹"
        "Ungern", "ðŸ‡­ðŸ‡º"
        "RumÃ¤nien", "ðŸ‡·ðŸ‡´"
        "Slovakien", "ðŸ‡¸ðŸ‡°"
        "Slovenien", "ðŸ‡¸ðŸ‡®"
        "Grekland", "ðŸ‡¬ðŸ‡·"
        "Irland", "ðŸ‡®ðŸ‡ª"
        "Wales", "ðŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿"
        "Albanien", "ðŸ‡¦ðŸ‡±"
        "Bulgarien", "ðŸ‡§ðŸ‡¬"
        "Bosnien", "ðŸ‡§ðŸ‡¦"
        "Nordmakedonien", "ðŸ‡²ðŸ‡°"
        "Luxemburg", "ðŸ‡±ðŸ‡º"
        "Georgien", "ðŸ‡¬ðŸ‡ª"
        "Kosovo", "ðŸ‡½ðŸ‡°"
        "Estland", "ðŸ‡ªðŸ‡ª"
        "Lettland", "ðŸ‡±ðŸ‡»"
        "Litauen", "ðŸ‡±ðŸ‡¹"
        "Montenegro", "ðŸ‡²ðŸ‡ª"
        "Armenien", "ðŸ‡¦ðŸ‡²"
        "Azerbajdzjan", "ðŸ‡¦ðŸ‡¿"
        "Israel", "ðŸ‡®ðŸ‡±"
        "Malta", "ðŸ‡²ðŸ‡¹"
        "Cypern", "ðŸ‡¨ðŸ‡¾"
        "Kazakstan", "ðŸ‡°ðŸ‡¿"
        "Liechtenstein", "ðŸ‡±ðŸ‡®"
        "Andorra", "ðŸ‡¦ðŸ‡©"
        "San Marino", "ðŸ‡¸ðŸ‡²"
        "FÃ¤rÃ¶arna", "ðŸ‡«ðŸ‡´"
        "Gibraltar", "ðŸ‡¬ðŸ‡®"
        "Moldavien", "ðŸ‡²ðŸ‡©"
        "Vitryssland", "ðŸ‡§ðŸ‡¾"
        "USA", "ðŸ‡ºðŸ‡¸"
        "Brasilien", "ðŸ‡§ðŸ‡·"
        "Argentina", "ðŸ‡¦ðŸ‡·"
        "Mexiko", "ðŸ‡²ðŸ‡½"
        "Japan", "ðŸ‡¯ðŸ‡µ"
        "Sydkorea", "ðŸ‡°ðŸ‡·"
        "Australien", "ðŸ‡¦ðŸ‡º"
        "Kanada", "ðŸ‡¨ðŸ‡¦"
        "Kina", "ðŸ‡¨ðŸ‡³"
        // LÃ¤gg till fler vid
    ]


let nameWithFlag (name: string) =
    // Handles names like "Sverige - Finland"
    let parts = name.Split([| " - " |], System.StringSplitOptions.None)
    parts
    |> Array.map (fun n ->
        match countryToFlag.TryFind n with
        | Some flag -> $"{flag} {n}"
        | None -> n)
    |> String.concat " - "

let stableHash (s: string) =
  s |> Seq.fold (fun acc c -> 33 * acc ^^^ int c) 5381

let colorPalette =
  [ "#1f77b4"; // blue
    "#ff7f0e"; // orange
    "#2ca02c"; // green
    "#d62728"; // red
    "#9467bd"; // purple
    "#8c564b"; // brown
    "#e377c2"; // pink
    "#7f7f7f"; // gray
    "#bcbd22"; // olive
    "#17becf"; // cyan
    // "#aec7e8"; // light blue
    // "#ffbb78"; // light orange
    // "#98df8a"; // light green
    // "#ff9896"; // light red
    // "#c5b0d5"; // light purple
    // "#c49c94"; // light brown
    // "#f7b6d2"; // light pink
    // "#c7c7c7"; // light gray
    // "#dbdb8d"; // light olive
    // "#9edae5"  // light cyan
  ]
  |> List.map Plotly.NET.Color.fromHex
let getColorForName (name: string) =
    let hash = abs (stableHash name)
    colorPalette[hash % colorPalette.Length]

#!fsharp

let results =
  "resultat.txt"
  |> File.ReadAllLines
  |> Array.map (fun s -> string s[0])
  |> Array.where (fun s -> s.Length > 0)
  |> List.ofArray

let matches =
    "matcher.txt"
    |> File.ReadAllLines
    |> List.ofArray

let betRows =
    let createBetRow (a: string array) = {
        Name = a[2]
        Winner = a[24 + 3] // 24 matches
        Guesses = a[3..26] |> List.ofArray  // 24 + 3 (timestamp parts) - 1 (0-based indexing)
    }
    "tipset.2025.txt"
    |> File.ReadAllLines
    |> Seq.where (fun l -> l.StartsWith('#') = false)
    |> Seq.map (fun l -> Regex.Split(l, @"\s+"))
    |> Seq.map createBetRow
    |> Seq.toList


let countCorrect i r =
    let count =
        betRows
        |> Seq.where (fun br -> br.Guesses[i] = r)
        |> Seq.length
        |> double
    let score =
        if count > 0 then (float betRows.Length) / count
        else 0
    score, r

let correctPerGame =
    results |> List.mapi countCorrect
let scoreGuesses (guesses: string list) =
    let scoreGame i (fs: float * string) =
        let f, s = fs
        if s = guesses[i] then f
        else 0
    correctPerGame
    |> List.mapi scoreGame
let scoredRowsFirst =
    let convertGuesses guesses =
        let scores = scoreGuesses guesses
        scores |> List.scan (+) 0.
    let createScoredRow (br: BetRow) =
        { Name = br.Name
          Scores = convertGuesses br.Guesses
          Guesses = br.Guesses }
    betRows
    |> List.map createScoredRow


let scoredRows =
    let addWinnerPoints (sc: ScoredRow) =
        { Name = sc.Name
          Scores = sc.Scores @ [100.]
          Guesses = sc.Guesses @ [ "F" ] }
    scoredRowsFirst
    //|> List.map addWinnerPoints


let createChart (sr: ScoredRow) =
    let xData = [0..results.Length]
    let sum = sr.Scores[results.Length]
    let chart = Chart.Spline(
        xData,
        sr.Scores,
        Name = $"%s{sr.Name} %.1f{sum}",
        Smoothing = 0.3,
        LineColor = getColorForName sr.Name,
        MarkerColor = getColorForName sr.Name,
        ShowMarkers = true,
        MultiText = [""] @ (sr.Guesses[0..results.Length - 1]),
        TextPosition = StyleParam.TextPosition.BottomCenter,
        ShowLegend = true)
    sum, chart

let description =
  if matches.Length > results.Length then
    [
      h3 [] [str "Kommande matcher och vÃ¥ra tips"]
      table [] [
        tr [] [
          th [] []
          for sr in scoredRows do
            th [] [str sr.Name]
        ]
        let stop = min 4 (matches.Length - results.Length)
        for m = 0 to stop - 1 do
          let mtch = matches[results.Length + m]
          tr [] [
            td [] [str (nameWithFlag mtch)]
            for sr in scoredRows do
              td [] [str sr.Guesses[results.Length + m]]
          ]
      ]
    ]
  else
    [
      h3 [] [str "VÃ¥ra slutvinnare"]
      table [] [
        tr [] [
          th [] [str "Namn"]
          th [] [str "Slutvinnare"]
        ]
        for br in betRows do
          tr [] [
            td [] [str br.Name]
            td [] [str br.Winner]
          ]
      ]
    ]

let myFirstChart =
    Chart.combine(
        scoredRows
        |> List.map createChart
        |> List.sortByDescending fst
        |> List.map snd
    )
    |> Chart.withTitle "EURO 2025 âš½ï¸"
    |> Chart.withAdditionalHeadTags
        [ link
              [ _rel "stylesheet"
                _href "https://cdn.jsdelivr.net/npm/bulma@0.9.2/css/bulma.min.css" ] ]
    |> Chart.withDescription(description)
myFirstChart |> Chart.savePNG("chart", Width = 1400, Height = 1000)
myFirstChart
